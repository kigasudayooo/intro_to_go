# 今日お勉強したこと
#go

[オライリーのやつ](https://learning.oreilly.com/library/view/chu-metenogoyan-yu-di-2ban-ta-yan-yu-puroguramanotamenoideiomateitukugoshi-jian-gaido/9784814401192/ch01.xhtml)

- Goのモジュールでは、コードは一つ以上のパッケージに分割される
  - mainパッケージは、実行可能なプログラムを定義する
  - モジュールとは何か
    - モジュールは、Goのコードを管理するための単位であり、関連するパッケージの集まりである
    - Pythonにもモジュールの概念がある。違いは以下
      - Pythonのモジュールは、ファイル単位で管理されるが、Goのモジュールは、ディレクトリ単位で管理される
      - Goのモジュールは、バージョン管理や、依存関係の管理が組み込まれている
- import宣言では、参照するパッケージを指定する
  - import "fmt"
    - fmtパッケージは、フォーマットされたI/Oを提供する
  - pythonとは異なり、一部の関数のみをインポートすることはできない

```go
package main                  // パッケージ宣言

import "fmt"                  // インポート宣言。パッケージfmtをインポート

func main() {                 // 関数宣言。「{」も同じ行に書く
fmt.Println("Hello, world!")  // パッケージfmtの関数Printlnを呼び出す
}
```


- 実行ファイルは、　$go build$で生成される
  - 生成された実行ファイルは、カレントディレクトリに作成される
  - 実行ファイルの名前は、モジュール名と同じになる
    - 名前を変えたい場合は、$go build -o <filename>$で指定できる
  - $go run hello.go$で、ビルドと実行を同時に行うこともできる
    - 外部のモジュールに依存しない場合に限る
      - 外部のモジュールとは、fmtパッケージのようにGoの標準ライブラリに含まれないパッケージのこと
    - この場合は、go.modファイルは不要
    - モジュール用にディレクトリを作る必要もない
- goは、フォーマットに標準があり、それを皆が用いるようになっている
  - 例えば、$ go fmt ./...$ で、カレントディレクトリと全てのサブディレクトリのファイルをフォーマットできる
  - 文末のセミコロンは自動で挿入される。このため、{は同じ行に書かないと、コンパイルエラーになる
- 構文的に問題でないものの、変なやつを検出するコマンドがある
  - go vet
    - 例えば、未使用の変数や、型の不一致などを検出する
    - 検出しきれないものもあるので、その時はサードパーティのツールを使う
      - 例えば、staticcheckやgolangci-lintなど
- Goのコードは、コメントを除いて、UTF-8でエンコードされている必要がある
  - コメントは、//で始まる行コメントと、/* */で囲まれたブロックコメントがある
    - ブロックコメントはsqlみたいだね。
  - コメントは、コードの可読性を高めるために重要である
- Makefile
  - 共通環境でビルドやテストを行うために、Makefileを用意することが多い
  - 例えば、以下のようなMakefileを用意することができる
```Makefile
.DEFAULT_GOAL := build

.PHONY:fmt vet build
fmt:
        go fmt ./...
vet: fmt
        go vet ./...
build: vet
        go build
```